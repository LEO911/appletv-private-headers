/**
 * This header is generated by class-dump-z 0.2a.
 * class-dump-z is Copyright (C) 2009 by KennyTM~, licensed under GPLv3.
 *
 * Source: /System/Library/PrivateFrameworks/MusicLibrary.framework/MusicLibrary
 */

typedef struct _NSZone NSZone;

typedef struct {
	unsigned _field1;
	unsigned _field2;
	unsigned _field3;
	unsigned _field4;
	BOOL _field5;
	BOOL _field6;
	BOOL _field7;
	BOOL _field8;
	BOOL _field9;
} XXStruct_JKTQzB;

typedef struct MLArtworkFormatSpec {
	unsigned _field1;
	unsigned _field2;
	unsigned _field3;
	unsigned _field4;
	int _field5;
	int _field6;
	BOOL _field7;
} MLArtworkFormatSpec;

typedef struct CGContext *CGContextRef;

typedef struct CGImage *CGImageRef;

typedef struct CGPoint {
	float _field1;
	float _field2;
} CGPoint;

typedef struct CGSize {
	float _field1;
	float _field2;
} CGSize;

typedef struct CGRect {
	CGPoint _field1;
	CGSize _field2;
} CGRect;

typedef struct CGColorSpace *CGColorSpaceRef;

typedef struct __CFDictionary *CFDictionaryRef;

typedef struct iPhoneSortKeyBuilder iPhoneSortKeyBuilder;

typedef struct {
	long long _field1;
	int _field2;
} XXStruct_Cy4r_A;

typedef struct _NSRange {
	unsigned location;
	unsigned length;
} NSRange;

typedef struct SearchCriteriaList SearchCriteriaList;

typedef struct ChapterData ChapterData;

typedef struct MLArtworkInstanceInfo {
	MLArtworkFormatSpec _field1;
	CGRect _field2;
} MLArtworkInstanceInfo;

typedef struct sqlite3_module {
	int _field1;
	/*function-pointer*/ void *_field2;
	/*function-pointer*/ void *_field3;
	/*function-pointer*/ void *_field4;
	/*function-pointer*/ void *_field5;
	/*function-pointer*/ void *_field6;
	/*function-pointer*/ void *_field7;
	/*function-pointer*/ void *_field8;
	/*function-pointer*/ void *_field9;
	/*function-pointer*/ void *_field10;
	/*function-pointer*/ void *_field11;
	/*function-pointer*/ void *_field12;
	/*function-pointer*/ void *_field13;
	/*function-pointer*/ void *_field14;
	/*function-pointer*/ void *_field15;
	/*function-pointer*/ void *_field16;
	/*function-pointer*/ void *_field17;
	/*function-pointer*/ void *_field18;
	/*function-pointer*/ void *_field19;
	/*function-pointer*/ void *_field20;
	/*function-pointer*/ void *_field21;
	/*function-pointer*/ void *_field22;
	/*function-pointer*/ void *_field23;
} sqlite3_module;

template<>
struct __compressed_pair<long long *, std::__1::allocator<long long> > {
	long long *__first_;
};

template<>
struct vector<long long, std::__1::allocator<long long> > {
	long long *__begin_;
	long long *__end_;
	__compressed_pair<long long *, std::__1::allocator<long long> > __end_cap_;
};

template<>
struct __compressed_pair<unsigned char *, std::__1::allocator<unsigned char> > {
	char *__first_;
};

template<>
struct vector<unsigned char, std::__1::allocator<unsigned char> > {
	char *__begin_;
	char *__end_;
	__compressed_pair<unsigned char *, std::__1::allocator<unsigned char> > __end_cap_;
};

template<>
struct __hash_node<long long, void *>;

template<>
struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<long long, void *> *> > {
	unsigned long __first_;
};

template<>
struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<long long, void *> *> > {
	__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<long long, void *> *> > __data_;
};

template<>
struct __compressed_pair<std::__1::__hash_node<long long, void *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<long long, void *> *> > > {
	__hash_node<long long, void *> **__first_;
	__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<long long, void *> *> > __second_;
};

template<>
struct unique_ptr<std::__1::__hash_node<long long, void *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<long long, void *> *> > > {
	__compressed_pair<std::__1::__hash_node<long long, void *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<long long, void *> *> > > __ptr_;
};

template<>
struct __hash_node_base<std::__1::__hash_node<long long, void *> *> {
	__hash_node<long long, void *> *__next_;
};

template<>
struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<long long, void *> *>, std::__1::allocator<std::__1::__hash_node<long long, void *> > > {
	__hash_node_base<std::__1::__hash_node<long long, void *> *> __first_;
};

template<>
struct __compressed_pair<unsigned long, std::__1::hash<long long> > {
	unsigned long __first_;
};

template<>
struct __compressed_pair<float, std::__1::equal_to<long long> > {
	float __first_;
};

template<>
struct __hash_table<long long, std::__1::hash<long long>, std::__1::equal_to<long long>, std::__1::allocator<long long> > {
	unique_ptr<std::__1::__hash_node<long long, void *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<long long, void *> *> > > __bucket_list_;
	__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<long long, void *> *>, std::__1::allocator<std::__1::__hash_node<long long, void *> > > __p1_;
	__compressed_pair<unsigned long, std::__1::hash<long long> > __p2_;
	__compressed_pair<float, std::__1::equal_to<long long> > __p3_;
};

template<>
struct unordered_set<long long, std::__1::hash<long long>, std::__1::equal_to<long long>, std::__1::allocator<long long> > {
	__hash_table<long long, std::__1::hash<long long>, std::__1::equal_to<long long>, std::__1::allocator<long long> > __table_;
};

template<>
struct __tree_node<std::__1::pair<unsigned long, unsigned int>, void *>;

template<>
struct __tree_node_base<void *>;

template<>
struct __tree_end_node<std::__1::__tree_node_base<void *> *> {
	__tree_node_base<void *> *__left_;
};

template<>
struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::pair<unsigned long, unsigned int>, void *> > > {
	__tree_end_node<std::__1::__tree_node_base<void *> *> __first_;
};

template<>
struct __compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, unsigned int, std::__1::less<unsigned long>, true> > {
	unsigned long __first_;
};

template<>
struct __tree<std::__1::pair<unsigned long, unsigned int>, std::__1::__map_value_compare<unsigned long, unsigned int, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::pair<unsigned long, unsigned int> > > {
	__tree_node<std::__1::pair<unsigned long, unsigned int>, void *> *__begin_node_;
	__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::pair<unsigned long, unsigned int>, void *> > > __pair1_;
	__compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long, unsigned int, std::__1::less<unsigned long>, true> > __pair3_;
};

template<>
struct map<unsigned long, unsigned int, std::__1::less<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, unsigned int> > > {
	__tree<std::__1::pair<unsigned long, unsigned int>, std::__1::__map_value_compare<unsigned long, unsigned int, std::__1::less<unsigned long>, true>, std::__1::allocator<std::__1::pair<unsigned long, unsigned int> > > __tree_;
};

template<>
struct __hash_node<std::__1::pair<long long, NSString *>, void *>;

template<>
struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *> > {
	unsigned long __first_;
};

template<>
struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *> > {
	__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *> > __data_;
};

template<>
struct __compressed_pair<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *> > > {
	__hash_node<std::__1::pair<long long, NSString *>, void *> **__first_;
	__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *> > __second_;
};

template<>
struct unique_ptr<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *> > > {
	__compressed_pair<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *> > > __ptr_;
};

template<>
struct __hash_node_base<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *> {
	__hash_node<std::__1::pair<long long, NSString *>, void *> *__next_;
};

template<>
struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> > > {
	__hash_node_base<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *> __first_;
};

template<>
struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<long long, NSString *, std::__1::hash<long long>, true> > {
	unsigned long __first_;
};

template<>
struct __compressed_pair<float, std::__1::__unordered_map_equal<long long, NSString *, std::__1::equal_to<long long>, true> > {
	float __first_;
};

template<>
struct __hash_table<std::__1::pair<long long, NSString *>, std::__1::__unordered_map_hasher<long long, NSString *, std::__1::hash<long long>, true>, std::__1::__unordered_map_equal<long long, NSString *, std::__1::equal_to<long long>, true>, std::__1::allocator<std::__1::pair<long long, NSString *> > > {
	unique_ptr<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *> > > __bucket_list_;
	__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, NSString *>, void *> > > __p1_;
	__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<long long, NSString *, std::__1::hash<long long>, true> > __p2_;
	__compressed_pair<float, std::__1::__unordered_map_equal<long long, NSString *, std::__1::equal_to<long long>, true> > __p3_;
};

template<>
struct unordered_map<long long, NSString *, std::__1::hash<long long>, std::__1::equal_to<long long>, std::__1::allocator<std::__1::pair<const long long, NSString *> > > {
	__hash_table<std::__1::pair<long long, NSString *>, std::__1::__unordered_map_hasher<long long, NSString *, std::__1::hash<long long>, true>, std::__1::__unordered_map_equal<long long, NSString *, std::__1::equal_to<long long>, true>, std::__1::allocator<std::__1::pair<long long, NSString *> > > __table_;
};

typedef struct NSNumber {
	Class _field1;
} NSNumber;

template<>
struct __hash_node<std::__1::pair<long long, CollectionPIDSet>, void *>;

template<>
struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *> > {
	unsigned long __first_;
};

template<>
struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *> > {
	__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *> > __data_;
};

template<>
struct __compressed_pair<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *> > > {
	__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> **__first_;
	__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *> > __second_;
};

template<>
struct unique_ptr<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *> > > {
	__compressed_pair<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *> > > __ptr_;
};

template<>
struct __hash_node_base<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *> {
	__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *__next_;
};

template<>
struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> > > {
	__hash_node_base<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *> __first_;
};

template<>
struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<long long, CollectionPIDSet, std::__1::hash<long long>, true> > {
	unsigned long __first_;
};

template<>
struct __compressed_pair<float, std::__1::__unordered_map_equal<long long, CollectionPIDSet, std::__1::equal_to<long long>, true> > {
	float __first_;
};

template<>
struct __hash_table<std::__1::pair<long long, CollectionPIDSet>, std::__1::__unordered_map_hasher<long long, CollectionPIDSet, std::__1::hash<long long>, true>, std::__1::__unordered_map_equal<long long, CollectionPIDSet, std::__1::equal_to<long long>, true>, std::__1::allocator<std::__1::pair<long long, CollectionPIDSet> > > {
	unique_ptr<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *> > > __bucket_list_;
	__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, CollectionPIDSet>, void *> > > __p1_;
	__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<long long, CollectionPIDSet, std::__1::hash<long long>, true> > __p2_;
	__compressed_pair<float, std::__1::__unordered_map_equal<long long, CollectionPIDSet, std::__1::equal_to<long long>, true> > __p3_;
};

template<>
struct unordered_map<long long, CollectionPIDSet, std::__1::hash<long long>, std::__1::equal_to<long long>, std::__1::allocator<std::__1::pair<const long long, CollectionPIDSet> > > {
	__hash_table<std::__1::pair<long long, CollectionPIDSet>, std::__1::__unordered_map_hasher<long long, CollectionPIDSet, std::__1::hash<long long>, true>, std::__1::__unordered_map_equal<long long, CollectionPIDSet, std::__1::equal_to<long long>, true>, std::__1::allocator<std::__1::pair<long long, CollectionPIDSet> > > __table_;
};

typedef struct MLRowDataSource *MLRowDataSourceRef;

template<>
struct __compressed_pair<MLRowDataSource **, std::__1::allocator<MLRowDataSource *> > {
	MLRowDataSourceRef *__first_;
};

template<>
struct vector<MLRowDataSource *, std::__1::allocator<MLRowDataSource *> > {
	MLRowDataSourceRef *__begin_;
	MLRowDataSourceRef *__end_;
	__compressed_pair<MLRowDataSource **, std::__1::allocator<MLRowDataSource *> > __end_cap_;
};

typedef struct {
	long long _field1;
	long long _field2;
	long long _field3;
	long long _field4;
	long long _field5;
	long long _field6;
	long long _field7;
} XXStruct_Jd0CAB;

template<>
struct __hash_node<std::__1::pair<long long, ML3NameOrder>, void *>;

template<>
struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *> > {
	unsigned long _field1;
};

template<>
struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *> > {
	__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *> > _field1;
};

template<>
struct __compressed_pair<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *> > > {
	__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> **_field1;
	__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *> > _field2;
};

template<>
struct unique_ptr<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *> > > {
	__compressed_pair<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *> > > _field1;
};

template<>
struct __hash_node_base<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *> {
	__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *_field1;
};

template<>
struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> > > {
	__hash_node_base<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *> _field1;
};

template<>
struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<long long, ML3NameOrder, std::__1::hash<long long>, true> > {
	unsigned long _field1;
};

template<>
struct __compressed_pair<float, std::__1::__unordered_map_equal<long long, ML3NameOrder, std::__1::equal_to<long long>, true> > {
	float _field1;
};

template<>
struct __hash_table<std::__1::pair<long long, ML3NameOrder>, std::__1::__unordered_map_hasher<long long, ML3NameOrder, std::__1::hash<long long>, true>, std::__1::__unordered_map_equal<long long, ML3NameOrder, std::__1::equal_to<long long>, true>, std::__1::allocator<std::__1::pair<long long, ML3NameOrder> > > {
	unique_ptr<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *> > > _field1;
	__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::pair<long long, ML3NameOrder>, void *> > > _field2;
	__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<long long, ML3NameOrder, std::__1::hash<long long>, true> > _field3;
	__compressed_pair<float, std::__1::__unordered_map_equal<long long, ML3NameOrder, std::__1::equal_to<long long>, true> > _field4;
};

template<>
struct unordered_map<long long, ML3NameOrder, std::__1::hash<long long>, std::__1::equal_to<long long>, std::__1::allocator<std::__1::pair<const long long, ML3NameOrder> > > {
	__hash_table<std::__1::pair<long long, ML3NameOrder>, std::__1::__unordered_map_hasher<long long, ML3NameOrder, std::__1::hash<long long>, true>, std::__1::__unordered_map_equal<long long, ML3NameOrder, std::__1::equal_to<long long>, true>, std::__1::allocator<std::__1::pair<long long, ML3NameOrder> > > _field1;
};

typedef struct sqlite3_stmt sqlite3_stmt;

typedef struct sqlite3_blob sqlite3_blob;

typedef struct sqlite3 sqlite3;


